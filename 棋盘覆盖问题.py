import pprint

def 棋盘递归(原点x坐标,原点y坐标,标记点x坐标,标记点y坐标,棋盘边长,棋盘,L序号=[0]): #原点坐标从0开始,标记点坐标从1开始,都为绝对坐标
    if 棋盘边长==1: return
    棋盘边长=int(棋盘边长/2)
    L序号[0]+=1
    L序号0=L序号[0]

    #如果标记点在左上
    if 原点x坐标+棋盘边长 >= 标记点x坐标 and 原点y坐标+棋盘边长 >= 标记点y坐标:
        棋盘递归(原点x坐标, 原点y坐标, 标记点x坐标, 标记点y坐标, 棋盘边长,棋盘,L序号)
    else:
        棋盘[原点y坐标+棋盘边长-1][原点x坐标+棋盘边长-1]=L序号0 #二维数组中的x轴和y轴相反
        棋盘递归(原点x坐标, 原点y坐标, 原点x坐标+棋盘边长, 原点y坐标+棋盘边长, 棋盘边长,棋盘,L序号)

    #如果标记点在右上
    if 原点x坐标+棋盘边长 < 标记点x坐标 and 原点y坐标+棋盘边长 >= 标记点y坐标:
        棋盘递归(原点x坐标+棋盘边长, 原点y坐标, 标记点x坐标, 标记点y坐标, 棋盘边长,棋盘,L序号)
    else:
        棋盘[原点y坐标+棋盘边长-1][原点x坐标+棋盘边长]=L序号0
        棋盘递归(原点x坐标+棋盘边长, 原点y坐标, 原点x坐标+棋盘边长+1, 原点y坐标+棋盘边长, 棋盘边长,棋盘,L序号)

    #如果标记点在左下
    if 原点x坐标+棋盘边长 >= 标记点x坐标 and 原点y坐标+棋盘边长 < 标记点y坐标:
        棋盘递归(原点x坐标, 原点y坐标+棋盘边长, 标记点x坐标, 标记点y坐标, 棋盘边长,棋盘,L序号)
    else:
        棋盘[原点y坐标+棋盘边长][原点x坐标+棋盘边长-1]=L序号0
        棋盘递归(原点x坐标, 原点y坐标+棋盘边长, 原点x坐标+棋盘边长, 原点y坐标+棋盘边长+1, 棋盘边长,棋盘,L序号)

    #如果标记点在右下
    if 原点x坐标+棋盘边长 < 标记点x坐标 and 原点y坐标+棋盘边长 < 标记点y坐标:
        棋盘递归(原点x坐标+棋盘边长, 原点y坐标+棋盘边长, 标记点x坐标, 标记点y坐标, 棋盘边长,棋盘,L序号)
    else:
        棋盘[原点y坐标+棋盘边长][原点x坐标+棋盘边长]=L序号0
        棋盘递归(原点x坐标+棋盘边长, 原点y坐标+棋盘边长, 原点x坐标+棋盘边长+1, 原点y坐标+棋盘边长+1, 棋盘边长,棋盘,L序号)

def 生成棋盘并计算L型覆盖(棋盘边长,特殊方格x坐标,特殊方格y坐标): #特殊方格坐标从1开始
    棋盘=[]
    for i in range(棋盘边长):
        棋盘.append([])
        for j in range(棋盘边长):
            棋盘[i].append(0)
    棋盘递归(0, 0, 特殊方格x坐标, 特殊方格y坐标, 棋盘边长,棋盘)
    for i in range(棋盘边长):
        for j in range(棋盘边长):
            print(str(棋盘[i][j])+'\t',end='')
        print()
    print('共计%d个L型覆盖'%((棋盘边长**2-1)/3))

生成棋盘并计算L型覆盖(2**3,1,2)